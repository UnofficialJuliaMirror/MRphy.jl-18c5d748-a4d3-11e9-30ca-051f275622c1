<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>MRphy.jl Documentation · MRphy.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>MRphy.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>MRphy.jl Documentation</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#Modules-1">Modules</a></li><li class="toplevel"><a class="toctext" href="#Constants-1">Constants</a></li><li class="toplevel"><a class="toctext" href="#Types-1">Types</a></li><li class="toplevel"><a class="toctext" href="#Functions-1">Functions</a></li><li><a class="toctext" href="#Utilities-1">Utilities</a></li><li><a class="toctext" href="#SteadyStates-1">SteadyStates</a></li><li class="toplevel"><a class="toctext" href="#Index-1">Index</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>MRphy.jl Documentation</a></li></ul><a class="edit-page" href="https://github.com/tianrluo/MRphy.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>MRphy.jl Documentation</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="MRphy.jl-Documentation-1" href="#MRphy.jl-Documentation-1">MRphy.jl Documentation</a></h1><h1><a class="nav-anchor" id="Modules-1" href="#Modules-1">Modules</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MRphy" href="#MRphy"><code>MRphy</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p><strong>General Comments:</strong></p><ul><li><code>nM</code>, number of spins, as magnetic spin vectors are often denoted as 𝑀.</li><li><code>nT</code>, number of steps/time-points.</li></ul><p><a href="https://github.com/PainterQubits/Unitful.jl"><code>Unitful.jl</code></a> related:</p><ul><li><code>𝐁 = 𝐌*𝐈^-1*𝐓^-2</code>, dimension of magnetic field strength.</li><li><code>𝐅 = 𝐓^-1</code>, dimension of temporal frequency.</li><li><code>𝐊 = 𝐋^-1</code>, dimension of spatial frequency.</li><li><code>𝚪 = 𝐅/𝐁</code>, dimension of gyro ratio.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/MRphy.jl#L1-L11">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MRphy.utils" href="#MRphy.utils"><code>MRphy.utils</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>Some utilities functions routinely used in MR simulations.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/utils.jl#L1-L3">source</a></section><p>See <a href="#Utilities-1">Utilities</a></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MRphy.SteadyStates" href="#MRphy.SteadyStates"><code>MRphy.SteadyStates</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>Some steady state properties of common sequences.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/SteadyStates.jl#L2-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MRphy.SteadyStates.Signal" href="#MRphy.SteadyStates.Signal"><code>MRphy.SteadyStates.Signal</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>Analytical expressions of common steady states sequences signals.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/SteadyStates.jl#L10-L12">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MRphy.SteadyStates.RFSpoiling" href="#MRphy.SteadyStates.RFSpoiling"><code>MRphy.SteadyStates.RFSpoiling</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>Tools for simulating RF spoiling in gradient echo sequences.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/SteadyStates.jl#L98-L100">source</a></section><p>See <a href="#SteadyStates-1">SteadyStates</a></p><h1><a class="nav-anchor" id="Constants-1" href="#Constants-1">Constants</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MRphy.γ¹H" href="#MRphy.γ¹H"><code>MRphy.γ¹H</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">const γ¹H = 4257.6u&quot;Hz/Gauss&quot;</code></pre><p>Gyromagnetic ratio of water proton.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/MRphy.jl#L159-L162">source</a></section><h1><a class="nav-anchor" id="Types-1" href="#Types-1">Types</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MRphy.AbstractPulse" href="#MRphy.AbstractPulse"><code>MRphy.AbstractPulse</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>An abstract type for pulses.</p><p>See also: <a href="#MRphy.Pulse"><code>Pulse</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/mObjects.jl#L7-L11">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MRphy.AbstractSpinArray" href="#MRphy.AbstractSpinArray"><code>MRphy.AbstractSpinArray</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>This type keeps the essentials of magnetic spins. Its instance struct must contain all fields listed listed in the exemplary struct <code>mSpinArray</code>.</p><p><strong>Misc</strong></p><p>Might make <code>AbstractSpinArray &lt;: AbstractArray</code> in a future version</p><p>See also: <a href="#MRphy.mSpinArray"><code>mSpinArray</code></a>, <a href="#MRphy.AbstractSpinCube"><code>AbstractSpinCube</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/mObjects.jl#L61-L69">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MRphy.AbstractSpinCube" href="#MRphy.AbstractSpinCube"><code>MRphy.AbstractSpinCube</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>AbstractSpinCube &lt;: AbstractSpinArray</code>. This type inherits <code>AbstractSpinArray</code> as a field. Its instance struct must contain all fields listed in the exemplary struct <code>mSpinCube</code>.</p><p>See also: <a href="#MRphy.AbstractSpinArray"><code>AbstractSpinArray</code></a>, <a href="#MRphy.mSpinCube"><code>mSpinCube</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/mObjects.jl#L142-L148">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MRphy.B0D" href="#MRphy.B0D"><code>MRphy.B0D</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">B0D = Quantity{&lt;:Real, 𝐁}</code></pre><p>Type of magetic field strength. Based on <a href="https://github.com/PainterQubits/Unitful.jl"><code>Unitful.Quantity</code></a>.</p><p><strong>Examples:</strong></p><pre><code class="language-julia-repl">julia&gt; (1u&quot;Gauss&quot;)::B0D
1 Gauss</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/MRphy.jl#L53-L63">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MRphy.F0D" href="#MRphy.F0D"><code>MRphy.F0D</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">F0D =  Quantity{&lt;:Real, 𝐅}</code></pre><p>Type of temporal frequency. Based on <a href="https://github.com/PainterQubits/Unitful.jl"><code>Unitful.Quantity</code></a>.</p><p><strong>Examples:</strong></p><pre><code class="language-julia-repl">julia&gt; (1u&quot;s^-1&quot;)::F0D
1 s^-1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/MRphy.jl#L118-L128">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MRphy.GR0D" href="#MRphy.GR0D"><code>MRphy.GR0D</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">GR0D = Quantity{&lt;:Real, 𝐁/𝐋}</code></pre><p>Type of magnetic gradient. Based on <a href="https://github.com/PainterQubits/Unitful.jl"><code>Unitful.Quantity</code></a>.</p><p><strong>Examples:</strong></p><pre><code class="language-julia-repl">julia&gt; (1u&quot;Gauss/cm&quot;)::GR0D
1 Gauss cm^-1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/MRphy.jl#L131-L141">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MRphy.K0D" href="#MRphy.K0D"><code>MRphy.K0D</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">K0D =  Quantity{&lt;:Real, 𝐊}</code></pre><p>Type of spatial frequency. Based on <a href="https://github.com/PainterQubits/Unitful.jl"><code>Unitful.Quantity</code></a>.</p><p><strong>Examples:</strong></p><pre><code class="language-julia-repl">julia&gt; (1u&quot;cm^-1&quot;)::K0D
1 cm^-1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/MRphy.jl#L92-L102">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MRphy.L0D" href="#MRphy.L0D"><code>MRphy.L0D</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">L0D = Quantity{&lt;:Real, 𝐋}</code></pre><p>Type of length. Based on <a href="https://github.com/PainterQubits/Unitful.jl"><code>Unitful.Quantity</code></a>.</p><p><strong>Examples:</strong></p><pre><code class="language-julia-repl">julia&gt; (1u&quot;cm&quot;)::L0D
1 cm</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/MRphy.jl#L79-L89">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MRphy.Pulse" href="#MRphy.Pulse"><code>MRphy.Pulse</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Pulse(rf, gr; dt=(4e-6)u&quot;s&quot;, des=&quot;generic pulse&quot;)</code></pre><p>A struct for typical MR pulses: <code>Pulse &lt;: AbstractPulse</code>.</p><p><strong>Fields:</strong></p><p><em>Mutable</em>:</p><ul><li><code>rf::TypeND(RF0D, [1,2])</code> (nT,) or (nT, nCoils).</li><li><code>gr::TypeND(GR0D, [2])</code> (nT, 3), where 3 accounts for x-y-z channels.</li><li><code>dt::T0D</code> (1,), simulation temporal step size, i.e., dwell time.</li><li><code>des::String</code>, an description of the pulse to be constructed.</li></ul><p>See also: <a href="#MRphy.AbstractPulse"><code>AbstractPulse</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/mObjects.jl#L19-L31">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MRphy.RF0D" href="#MRphy.RF0D"><code>MRphy.RF0D</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">RF0D = Quantity{&lt;:Union{Real, Complex}, 𝐁}</code></pre><p>Type of magnetic RF. Based on <a href="https://github.com/PainterQubits/Unitful.jl"><code>Unitful.Quantity</code></a>.</p><p><strong>Examples:</strong></p><pre><code class="language-julia-repl">julia&gt; ((1+1im)u&quot;Gauss&quot;)::RF0D
1 + 1im Gauss</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/MRphy.jl#L144-L154">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MRphy.T0D" href="#MRphy.T0D"><code>MRphy.T0D</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">T0D = Quantity{&lt;:Real, 𝐓}</code></pre><p>Type of time. Based on <a href="https://github.com/PainterQubits/Unitful.jl"><code>Unitful.Quantity</code></a>.</p><p><strong>Examples:</strong></p><pre><code class="language-julia-repl">julia&gt; (1u&quot;s&quot;)::T0D
1 s</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/MRphy.jl#L105-L115">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MRphy.mSpinArray" href="#MRphy.mSpinArray"><code>MRphy.mSpinArray</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">mSpinArray(dim::Dims; T1=1.47u&quot;s&quot;, T2=0.07u&quot;s&quot;, γ=γ¹H, M=[0. 0. 1.])
mSpinArray(mask::BitArray; T1=1.47u&quot;s&quot;, T2=0.07u&quot;s&quot;, γ=γ¹H, M=[0. 0. 1.])</code></pre><p>An exemplary struct instantiating <code>AbstractSpinArray</code>.</p><p><strong>Fields:</strong></p><p><em>Immutable</em>:</p><ul><li><code>dim::Dims</code> (nd,): <code>nM ← prod(dim)</code>, dimension of the object.</li><li><code>mask::BitArray</code> (nx,(ny,(nz))): Mask for <code>M</code>, <code>dim == (nx,(ny,(nz)))</code></li></ul><p><em>Mutable</em>:</p><ul><li><code>T1::TypeND(T0D, [0,1])</code> (1,) or (nM,): Longitudinal relaxation coeff.</li><li><code>T2::TypeND(T0D, [0,1])</code> (1,) or (nM,): Transversal relaxation coeff.</li><li><code>γ::TypeND(Γ0D, [0,1])</code>  (1,) or (nM,): Gyromagnetic ratio.</li><li><code>M::TypeND(Real, [2])</code>   (<code>count(mask)</code>, 3):  Magnetic spins, (𝑀x,𝑀y,𝑀z).</li></ul><p><strong>Notes:</strong></p><p>off-resonance, <code>Δf</code>, and locations, <code>loc</code>, are intentionally unincluded, as they are not intrinsic to spins, and can change over time. Unincluding them allows extensional subtypes specialized for, e.g., arterial spin labelling.</p><p>See also: <a href="#MRphy.AbstractSpinArray"><code>AbstractSpinArray</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/mObjects.jl#L92-L113">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MRphy.mSpinCube" href="#MRphy.mSpinCube"><code>MRphy.mSpinCube</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">spincube = mSpinCube(dim::Dims{3}, fov; ofst, Δf, T1, T2, γ)
spincube = mSpinCube(mask::BitArray{3}, fov; ofst, Δf, T1, T2, γ)</code></pre><p><code>dim</code>, <code>mask</code>, <code>T1</code>, <code>T2</code>, and <code>γ</code> are passed to <code>mSpinArray</code> constructors.</p><p>An exemplary struct instantiating <code>AbstractSpinCube</code>, designed to model a set of regularly spaced spins, e.g., a volume.</p><p><strong>Fields:</strong></p><p><em>Immutable</em>:</p><ul><li><code>spinarray::AbstractSpinArray</code> (1,): inherited <code>AbstractSpinArray</code> struct</li><li><code>fov::NTuple{3,L0D}</code> (3,): field of view.</li><li><code>ofst::NTuple{3,L0D}</code> (3,): fov offset from magnetic field iso-center.</li><li><code>loc::TypeND(L0D, [2])</code>  (nM, 3): location of spins.</li></ul><p><em>Mutable</em>:</p><ul><li><code>Δf::TypeND(F0D, [0,1])</code> (1,) or (nM,): off-resonance map.</li></ul><p>See also: <a href="#MRphy.AbstractSpinCube"><code>AbstractSpinCube</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/mObjects.jl#L168-L186">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MRphy.Γ0D" href="#MRphy.Γ0D"><code>MRphy.Γ0D</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Γ0D = Quantity{&lt;:Real, 𝚪}</code></pre><p>Type of gyro magnetic ratio. Based on <a href="https://github.com/PainterQubits/Unitful.jl"><code>Unitful.Quantity</code></a>.</p><p><strong>Examples:</strong></p><pre><code class="language-julia-repl">julia&gt; (1u&quot;Hz/Gauss&quot;)::Γ0D
1 Hz Gauss^-1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/MRphy.jl#L66-L76">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MRphy.AbstractSpinBolus" href="#MRphy.AbstractSpinBolus"><code>MRphy.AbstractSpinBolus</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><em>UNDER CONSTRUCTION</em></p><p><code>AbstractSpinBolus &lt;: AbstractSpinArray</code>. This type inherits <code>AbstractSpinArray</code> as a field. Its instance struct must contain all fields listed in the exemplary struct <code>mSpinBolus</code>.</p><p>See also: <a href="#MRphy.AbstractSpinArray"><code>AbstractSpinArray</code></a>, <a href="#MRphy.mSpinBolus"><code>mSpinBolus</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/mObjects.jl#L211-L219">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MRphy.mSpinBolus" href="#MRphy.mSpinBolus"><code>MRphy.mSpinBolus</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><em>UNDER CONSTRUCTION</em></p><p>An exemplary struct instantiating <code>AbstractSpinBolus</code>, designed to model a set of moving spins, e.g., a blood bolus in ASL context.</p><p>See also: <a href="#MRphy.AbstractSpinBolus"><code>AbstractSpinBolus</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/mObjects.jl#L235-L242">source</a></section><h1><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MRphy.TypeND" href="#MRphy.TypeND"><code>MRphy.TypeND</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">TypeND(T,Ns) = Union{AbstractArray{&lt;:T,Ns[1]}, AbstractArray{&lt;:T,Ns[2]},...}</code></pre><p>Sugar for creating <code>Union</code>{<code>&lt;:T</code> typed array of different dimensions}.</p><p><strong>Usage</strong></p><p><em>INPUTS</em>:</p><ul><li><code>T::Type</code> (1,), the underlying type of the union.</li><li><code>Ns::Array{Int64,1}</code> (# diff dims,), an array of wanted dimensions.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/MRphy.jl#L27-L35">source</a><div><div><pre><code class="language-none">TypeND(T, ::Colon) = AbstractArray{&lt;:T}</code></pre><p>Sugar for creating <code>&lt;:T</code> typed array of arbitrary dimensions.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/MRphy.jl#L45-L48">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MRphy.rfgr2B" href="#MRphy.rfgr2B"><code>MRphy.rfgr2B</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">B = rfgr2B(rf, gr, loc=[0 0 0]u&quot;cm&quot;; Δf=0u&quot;Hz&quot;, b1Map=1, γ=γ¹H)</code></pre><p>Turn rf, <code>rf</code>, and gradient, <code>gr</code>, into 𝐵-effective magnetic field.</p><p><em>INPUTS</em>:</p><ul><li><code>rf::TypeND(RF0D, [1,2])</code> (nT, (nCoil))</li><li><code>gr::TypeND(GR0D, [2])</code>   (nT, 3)</li><li><code>loc::TypeND(L0D, [2])</code>   (1,3) or (nM, 3), locations.</li></ul><p><em>KEYWORDS</em>:</p><ul><li><code>Δf::TypeND(F0D, [0,1,2])</code> (1,)  or (nM,), off-resonance.</li><li><code>b1Map::TypeND(Union{Real,Complex},[0,1,2])</code> (1,) or (nM,(nCoils)),  transmit sensitivity.</li><li><code>γ::TypeND(Γ0D, [0,1])</code> (1,)  or (nM,), gyro-ratio</li></ul><p><em>OUTPUS</em>:</p><ul><li><code>B</code>, generator of <code>TypeND(B0D, [2])</code> (1,1,nT), 𝐵 field.</li></ul><p>See also: <a href="#MRphy.Pulse2B"><code>Pulse2B</code></a>, <a href="#MRphy.blochSim"><code>blochSim</code></a>.</p><p><strong>TODO:</strong></p><p>Support <code>loc</code>, <code>Δf</code>, and <code>b1Map</code> being <code>Base.Generators</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/blochSim.jl#L5-L25">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MRphy.Pulse2B" href="#MRphy.Pulse2B"><code>MRphy.Pulse2B</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">B = Pulse2B(pulse::Pulse, loc; Δf, b1Map, γ)</code></pre><p>Create effective magnetic field, 𝐵, from input <code>pulse</code>.</p><p>See also: <a href="#MRphy.rfgr2B"><code>rfgr2B</code></a>, <a href="#MRphy.B2UΦ"><code>B2UΦ</code></a>, <a href="#MRphy.blochSim"><code>blochSim</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/mObjects.jl#L251-L256">source</a><div><div><pre><code class="language-none">B = Pulse2B(pulse::Pulse, spa::AbstractSpinArray, loc; Δf, b1Map)</code></pre><p>...with <code>γ=spa.γ</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/mObjects.jl#L259-L262">source</a><div><div><pre><code class="language-none">B = Pulse2B(pulse::Pulse, cb::AbstractSpinCube; b1Map)</code></pre><p>...with <code>loc, Δf, γ = cb.loc, cb.Δf, cb.γ</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/mObjects.jl#L266-L269">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MRphy.blochSim" href="#MRphy.blochSim"><code>MRphy.blochSim</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">blochSim(M, B; T1, T2, γ, dt, doHist)</code></pre><p>Same as <code>blochSim!(M, B; T1,T2,γ,dt,doHist)</code>, <code>M</code> will not be updated.</p><p>See also: <a href="#MRphy.blochSim"><code>blochSim</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/blochSim.jl#L292-L297">source</a><div><div><pre><code class="language-none">blochSim(M, A, B)</code></pre><p>Same as <code>blochSim(M, A, B)</code>, <code>M</code> will not be updated.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/blochSim.jl#L300-L303">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MRphy.blochSim!" href="#MRphy.blochSim!"><code>MRphy.blochSim!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">blochSim!(M, B; T1=(Inf)u&quot;s&quot;,T2=(Inf)u&quot;s&quot;,γ=γ¹H,dt=(4e-6)u&quot;s&quot;,doHist=false)</code></pre><p>Old school 𝐵-effective magnetic field, <code>B</code>, based bloch simulation. Globally or spin-wisely apply <code>B</code> over spins, <code>M</code>. <code>M</code> will be updated by the results.</p><p><em>INPUTS</em>:</p><ul><li><code>M::TypeND(Real, [2])</code> (nM, xyz): input spins&#39; magnetizations.</li><li><code>B::Union{TypeND(B0D, [2,3]), Base.Generator}</code>: Global, (nT,xyz); Spin-wise, (nM,xyz,nT).</li></ul><p><em>KEYWORDS</em>:</p><ul><li><code>T1 &amp; T2 ::TypeND(T0D, [0,1])</code>: Global, (1,); Spin-wise, (nM,1).</li><li><code>γ::TypeND(Γ0D, [0,1])</code>: Global, (1,); Spin-wise, (nM, 1). gyro ratio</li><li><code>dt::T0D</code> (1,), simulation temporal step size, i.e., dwell time.</li><li><code>doHist::Bool</code>, whether to output spin history through out <code>B</code>.</li></ul><p><em>OUTPUTS</em>:</p><ul><li><code>M::TypeND(Real, [2])</code> (nM, xyz): spins after applying <code>B</code>.</li><li><code>Mhst::TypeND(Real, [3])</code> (nM, xyz, nT): spins history during <code>B</code>.</li></ul><p>See also: <a href="#MRphy.applyPulse"><code>applyPulse</code></a>, <a href="#MRphy.blochSim!"><code>blochSim!</code></a>.</p><p><strong>Notes:</strong></p><ol><li>Not much sanity check inside this function, user is responsible for matching up the dimensions.</li><li>Put relax at the end of each time step may still be inaccurate, since physically spins relax continuously, this noise/nuance may worth study for applications like fingerprinting simulations, etc.</li></ol></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/blochSim.jl#L195-L221">source</a><div><div><pre><code class="language-none">blochSim!(M, A, B)</code></pre><p>Hargreave&#39;s 𝐴/𝐵, mat/vec, based bloch simulation. Globally or spin-wisely apply matrix <code>A</code> and vector <code>B</code> over spins, <code>M</code>, described in doi:10.1002/mrm.1170</p><p><em>INPUTS</em>:</p><ul><li><code>M::TypeND(Real, [2])</code> (nM, xyz): input spins&#39; magnetizations.</li><li><code>A::TypeND(AbstractFloat,[3])</code> (nM, 3,3), <code>A[iM,:,:]</code> is the <code>iM</code>-th 𝐴.</li><li><code>B::TypeND(AbstractFloat,[2])</code> (nM, 3), <code>B[iM,:]</code> is the <code>iM</code>-th 𝐵.</li></ul><p><em>OUTPUTS</em>:</p><ul><li><code>M::TypeND(Real, [2])</code> (nM, xyz): spins after applying <code>B</code>.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/blochSim.jl#L278-L289">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MRphy.B2AB" href="#MRphy.B2AB"><code>MRphy.B2AB</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">B2AB(B; T1=(Inf)u&quot;s&quot;, T2=(Inf)u&quot;s&quot;, γ=γ¹H, dt=(4e-6)u&quot;s&quot;)</code></pre><p>Turn B-effective into Hargreave&#39;s 𝐴/𝐵, mat/vec, see: doi:10.1002/mrm.1170.</p><p><em>INPUTS</em>:</p><ul><li><code>B::Union{TypeND(B0D, [2,3]), Base.Generator}</code>: Global, (nT,xyz); Spin-wise, (nM,xyz,nT).</li></ul><p><em>KEYWORDS</em>:</p><ul><li><code>T1 &amp; T2 ::TypeND(T0D, [0,1])</code>: Global, (1,); Spin-wise, (nM,1).</li><li><code>γ::TypeND(Γ0D, [0,1])</code>: Global, (1,); Spin-wise, (nM, 1). gyro ratio</li><li><code>dt::T0D</code> (1,), simulation temporal step size, i.e., dwell time.</li></ul><p><em>OUTPUTS</em>:</p><ul><li><code>A::TypeND(AbstractFloat,[3])</code> (nM, 3,3), <code>A[iM,:,:]</code> is the <code>iM</code>-th 𝐴.</li><li><code>B::TypeND(AbstractFloat,[2])</code> (nM, 3), <code>B[iM,:]</code> is the <code>iM</code>-th 𝐵.</li></ul><p>See also: <a href="#MRphy.rfgr2B"><code>rfgr2B</code></a>, <a href="#MRphy.Pulse2B"><code>Pulse2B</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/blochSim.jl#L138-L154">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MRphy.B2UΦ" href="#MRphy.B2UΦ"><code>MRphy.B2UΦ</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">B2UΦ(B::TypeND(B0D,[2,3]); γ::TypeND(Γ0D,[0,1]), dt::T0D=4e-6u&quot;s&quot;)</code></pre><p>Given 𝐵-effective, <code>B</code>, compute rotation axis/angle, <code>U</code>/<code>Φ</code>.</p><p><em>INPUTS</em>:</p><ul><li><code>B::TypeND(B0D, [2,3])</code> (1,3,nT) or (nM, 3, nT), 𝐵 field.</li></ul><p><em>KEYWORDS</em>:</p><ul><li><code>γ::TypeND(Γ0D, [0,1])</code>: Global, (1,); Spin-wise, (nM, 1). gyro ratio</li><li><code>dt::T0D</code> (1,), simulation temporal step size, i.e., dwell time.</li></ul><p><em>OUTPUTS</em>:</p><ul><li><code>U::TypeND(Real, [2,3])</code> (1,3,(nT)) or (nM,3,(nT)), axis.</li><li><code>Φ::TypeND(Real, [2,3])</code> (1,1,(nT)) or (nM,1,(nT)), angle.</li></ul><p>See also: <a href="#MRphy.B2UΦ!"><code>B2UΦ!</code></a>, <a href="#MRphy.UΦRot!"><code>UΦRot!</code></a>.</p><p><strong>Notes:</strong></p><p>Somehow, in-place version, <code>B2UΦ!(B,U,Φ; γ,dt)</code>, provokes more allocs in julia.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/blochSim.jl#L51-L68">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MRphy.B2UΦ!" href="#MRphy.B2UΦ!"><code>MRphy.B2UΦ!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">B2UΦ!(B, U; Φ, γ, dt=(4e-6)u&quot;s&quot;)</code></pre><p>In-place version of <code>B2UΦ</code>. Somehow, <code>B2UΦ!</code>, provokes more allocs in julia.</p><p>See also: <a href="#MRphy.B2UΦ"><code>B2UΦ</code></a>, <a href="#MRphy.blochSim"><code>blochSim</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/blochSim.jl#L79-L84">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MRphy.UΦRot" href="#MRphy.UΦRot"><code>MRphy.UΦRot</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">UΦRot(U, Φ, V)</code></pre><p>Same as <code>UΦRot!(U, Φ, V, R)</code>, except not in-place.</p><p>See also: <a href="#MRphy.UΦRot!"><code>UΦRot!</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/blochSim.jl#L128-L133">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MRphy.UΦRot!" href="#MRphy.UΦRot!"><code>MRphy.UΦRot!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">UΦRot!(U, Φ, V, R)</code></pre><p>Apply axis-angle, <code>U</code>-<code>Φ</code> based rotation on <code>V</code>. Rotation is broadcasted on <code>V</code> along its 3rd dimension. Results will overwrite into <code>R</code>.</p><p><em>INPUTS</em>:</p><ul><li><code>U::TypeND(AbstractFloat,[2])</code> (nM, 3), rotation axes in 3D, assumed unitary;</li><li><code>Φ::TypeND(AbstractFloat,[1])</code> (nM,), rotation angles;</li><li><code>V::TypeND(AbstractFloat,[2,3])</code> (nM, 3, (3)), vectors to be rotated;</li><li><code>R::TypeND(AbstractFloat,[2,3])</code> (nM, 3, (3)), vectors rotated, i.e., results;</li></ul><p><em>OUTPUTS</em>:</p><ul><li><code>R</code> the input container <code>R</code> is also returned for convenience.</li></ul><p>See also: <a href="#MRphy.UΦRot"><code>UΦRot</code></a>, <a href="#MRphy.B2UΦ!"><code>B2UΦ!</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/blochSim.jl#L98-L112">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MRphy.applyPulse" href="#MRphy.applyPulse"><code>MRphy.applyPulse</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">applyPulse(spa::AbstractSpinArray, p::Pulse, loc; Δf, b1Map, doHist)</code></pre><p>Turn <code>p</code> into 𝐵-effective and apply it on <code>spa.M</code>, using its own <code>M, T1, T2, γ</code>.</p><p>See also: <a href="#MRphy.blochSim"><code>blochSim</code></a>, <a href="#MRphy.freePrec"><code>freePrec</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/mObjects.jl#L274-L279">source</a><div><div><pre><code class="language-none">applyPulse(cb::AbstractSpinCube, p::Pulse; b1Map, doHist)</code></pre><p>Turn <code>p</code> into 𝐵-effective and apply it on <code>cb.M</code>, using its own <code>M, T1, T2, γ</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/mObjects.jl#L294-L297">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MRphy.applyPulse!" href="#MRphy.applyPulse!"><code>MRphy.applyPulse!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">applyPulse!(spa::AbstractSpinArray, p::Pulse, loc; Δf, b1Map, doHist)</code></pre><p>Update <code>spa.M</code> before return.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/mObjects.jl#L284-L287">source</a><div><div><pre><code class="language-none">applyPulse!(cb::AbstractSpinCube, p::Pulse; b1Map, doHist)</code></pre><p>Update <code>cb.M</code> before return.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/mObjects.jl#L302-L305">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MRphy.freePrec" href="#MRphy.freePrec"><code>MRphy.freePrec</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">freePrec(M, t; Δf, T1, T2)</code></pre><p>Same as <code>freePrec!(M, t; Δf, T1, T2)</code>, <code>M</code> will not be updated.</p><p>See also: <a href="#MRphy.freePrec!"><code>freePrec!</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/blochSim.jl#L347-L352">source</a><div><div><pre><code class="language-none">freePrec(spa::AbstractSpinArray, t; Δf)</code></pre><p><code>spa::AbstractSpinArray</code> free precess by <code>t</code>. <code>spa.M</code> will not be updated.</p><p>See also: <a href="#MRphy.applyPulse"><code>applyPulse</code></a>, <a href="#MRphy.freePrec!"><code>freePrec!</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/mObjects.jl#L313-L318">source</a><div><div><pre><code class="language-none">freePrec(cb::AbstractSpinCube, t)</code></pre><p><code>cb::AbstractSpinCube</code> free precess by <code>t</code>. <code>cb.M</code> will not be updated.</p><p>See also: <a href="#MRphy.applyPulse"><code>applyPulse</code></a>, <a href="#MRphy.freePrec"><code>freePrec</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/mObjects.jl#L329-L334">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MRphy.freePrec!" href="#MRphy.freePrec!"><code>MRphy.freePrec!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">freePrec!(M, t; Δf=0u&quot;Hz&quot;, T1=(Inf)u&quot;s&quot;, T2=(Inf)u&quot;s&quot;)</code></pre><p>Spins, <code>M</code>, free precess by time <code>t</code>. <code>M</code> will be updated by the results.</p><p><em>INPUTS</em>:</p><ul><li><code>M::TypeND(Real, [2])</code> (nM, xyz): input spins&#39; magnetizations.</li><li><code>t::T0D</code> (1,): duration of free precession.</li></ul><p><em>KEYWORDS</em>:</p><ul><li><code>T1 &amp; T2 ::TypeND(T0D, [0,1])</code>: Global, (1,); Spin-wise, (nM,1).</li></ul><p><em>OUTPUTS</em>:</p><ul><li><code>M::TypeND(Real, [2])</code> (nM, xyz): output spins&#39; magnetizations.</li></ul><p>See also: <a href="#MRphy.freePrec"><code>freePrec</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/blochSim.jl#L314-L327">source</a><div><div><pre><code class="language-none">freePrec!(spa::AbstractSpinArray, t; Δf)</code></pre><p>...<code>spa.M</code> will updated by the results.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/mObjects.jl#L322-L325">source</a><div><div><pre><code class="language-none">freePrec!(cb::AbstractSpinCube, t)</code></pre><p>...<code>cb.M</code> will be updated by the results.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/mObjects.jl#L338-L341">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MRphy.ExceptionImmutableField" href="#MRphy.ExceptionImmutableField"><code>MRphy.ExceptionImmutableField</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Throw <code>ArgumentError</code> when <code>$x</code> is an immutable field.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/mObjects.jl#L1">source</a></section><h2><a class="nav-anchor" id="Utilities-1" href="#Utilities-1">Utilities</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MRphy.utils.CartesianLocations" href="#MRphy.utils.CartesianLocations"><code>MRphy.utils.CartesianLocations</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">CartesianLocations(dim::Dims, doShift::Bool=true)</code></pre><p>Retuns a <code>(prod(dim),length(dim))</code> sized array of grid locations. <code>doShift</code> shifts the locations to be consistent with <code>fftshift</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; loc = [CartesianLocations((2,2)), CartesianLocations((2,2),false)]
2-element Array{Array{Int64,2},1}:
 [-1 -1; 0 -1; -1 0; 0 0]
 [1 1; 2 1; 1 2; 2 2]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/utils.jl#L10-L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MRphy.utils.ctrInd-Tuple{Tuple{Vararg{Int64,N}} where N}" href="#MRphy.utils.ctrInd-Tuple{Tuple{Vararg{Int64,N}} where N}"><code>MRphy.utils.ctrInd</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ctrInd(dim::Dims) = sum((dim.÷2) .* [1; cumprod([dim[1:end-1]...])])+1</code></pre><p>As a separate fn, ensure consistent behariour of getting the linear index to the center of a Nd-array of size <code>dim</code>. This <code>center</code> should match <code>fftshift</code>&#39;s <code>center</code>.</p><p>See also: <a href="#MRphy.utils.ctrSub-Tuple{Tuple{Vararg{Int64,N}} where N}"><code>ctrSub</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/utils.jl#L44-L52">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MRphy.utils.ctrSub-Tuple{Tuple{Vararg{Int64,N}} where N}" href="#MRphy.utils.ctrSub-Tuple{Tuple{Vararg{Int64,N}} where N}"><code>MRphy.utils.ctrSub</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ctrSub(dim::Dims) = CartesianIndex(dim .÷ 2 .+ 1)</code></pre><p>As a separate function, ensure consistent behaviour of getting ::CartesianIndex to the center of a Nd-Array of size <code>dim</code>. This <code>center</code> should match <code>fftshift</code>&#39;s <code>center</code>.</p><p>See also: <a href="#MRphy.utils.ctrInd-Tuple{Tuple{Vararg{Int64,N}} where N}"><code>ctrInd</code></a>.</p><p><strong>Notes:</strong></p><p>The function may be removed once julia FFT packages provides this functionality.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/utils.jl#L29-L40">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MRphy.utils.g2k" href="#MRphy.utils.g2k"><code>MRphy.utils.g2k</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">g2k(g::TypeND(GR0D,:); isTx::Bool=false, dt::T0D=4e-6u&quot;s&quot;, γ::Γ0D=γ¹H)</code></pre><p>Compute k-space from gradient.</p><p><strong>Usage</strong></p><p><em>INPUTS</em>:</p><ul><li><code>g::TypeND(GR0D, :)</code> (nSteps, Nd...), gradient</li><li><code>isTx::Bool</code>, if <code>true</code>, compute transmit k-space, <code>k</code>, ends at the origin.</li></ul><p><em>KEYWORDS</em>:</p><ul><li><code>dt::T0D</code> (1,), gradient temporal step size, i.e., dwell time.</li><li><code>γ::Γ0D</code> (1,), gyro-ratio.</li></ul><p><em>OUTPUTS</em>:</p><ul><li><code>k::TypeND(K0D, :)</code> (nSteps, Nd...), k-space, w/ unit u&quot;cm^-1&quot;.</li></ul><p>See also: <a href="#MRphy.utils.k2g"><code>k2g</code></a>, <a href="#MRphy.utils.g2s-Tuple{AbstractArray{#s12,N} where N where #s12&lt;:(Unitful.Quantity{#s12,𝐌*𝐈^-1*𝐋^-1*𝐓^-2,U} where U where #s12&lt;:Real)}"><code>g2s</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/utils.jl#L81-L96">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MRphy.utils.g2s-Tuple{AbstractArray{#s12,N} where N where #s12&lt;:(Unitful.Quantity{#s12,𝐌*𝐈^-1*𝐋^-1*𝐓^-2,U} where U where #s12&lt;:Real)}" href="#MRphy.utils.g2s-Tuple{AbstractArray{#s12,N} where N where #s12&lt;:(Unitful.Quantity{#s12,𝐌*𝐈^-1*𝐋^-1*𝐓^-2,U} where U where #s12&lt;:Real)}"><code>MRphy.utils.g2s</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">g2s(g::TypeND(GR0D,:); dt::T0D=4e-6u&quot;s&quot;)</code></pre><p>Slew rate <code>sl</code>, of the gradient, <code>g</code>.</p><p><strong>Usage</strong></p><p><em>INPUTS</em>:</p><ul><li><code>g::TypeND(GR0D, :)</code> (nSteps, Nd...)</li></ul><p><em>KEYWORDS</em>:</p><ul><li><code>dt::T0D</code> (1,), gradient temporal step size, i.e., dwell time.</li></ul><p><em>OUTPUTS</em>:</p><ul><li><code>sl::TypeND(Quantity{&lt;:Real, 𝐁/𝐋/𝐓, :)</code> (nSteps, Nd...), slew rate</li></ul><p>See also: <a href="#MRphy.utils.g2k"><code>g2k</code></a>, <a href="#MRphy.utils.k2g"><code>k2g</code></a>.</p><p><strong>Note</strong></p><p>No <code>s2g</code> is provided for the moment.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/utils.jl#L101-L117">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MRphy.utils.k2g" href="#MRphy.utils.k2g"><code>MRphy.utils.k2g</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">k2g(k::TypeND(K0D,:), isTx::Bool=false; dt::T0D=4e-6u&quot;s&quot;, γ::Γ0D=γ¹H)</code></pre><p>Gradient, <code>g</code>, of the <code>TxRx</code> k-space, (trasmit/receive, excitation/imaging).</p><p><strong>Usage</strong></p><p><em>INPUTS</em>:</p><ul><li><code>k::TypeND(K0D, :)</code> (nSteps, Nd...), Tx or Rx k-space, w/ unit u&quot;cm^-1&quot;.</li><li><code>isTx::Bool</code>, if <code>true</code>, compute transmit k-space, <code>k</code>, ends at the origin.</li></ul><p><em>KEYWORDS</em>:</p><ul><li><code>dt::T0D</code> (1,), gradient temporal step size, i.e., dwell time.</li><li><code>γ::Γ0D</code> (1,), gyro-ratio.</li></ul><p><em>OUTPUTS</em>:</p><ul><li><code>g::TypeND(GR0D, :)</code> (nSteps, Nd...), gradient</li></ul><p><strong>Note</strong></p><p>The function asserts if <code>k</code> ends at the origin for <code>isTx==true</code>.</p><p>See also: <a href="#MRphy.utils.g2k"><code>g2k</code></a>, <a href="#MRphy.utils.g2s-Tuple{AbstractArray{#s12,N} where N where #s12&lt;:(Unitful.Quantity{#s12,𝐌*𝐈^-1*𝐋^-1*𝐓^-2,U} where U where #s12&lt;:Real)}"><code>g2s</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/utils.jl#L57-L75">source</a></section><h2><a class="nav-anchor" id="SteadyStates-1" href="#SteadyStates-1">SteadyStates</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MRphy.SteadyStates.Signal.SPGR-Tuple{Real}" href="#MRphy.SteadyStates.Signal.SPGR-Tuple{Real}"><code>MRphy.SteadyStates.Signal.SPGR</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">SPGR(α; TR, T1)</code></pre><p><code>TE=0</code> Steady state SPGR signal. 10.1002/mrm.1910130109, eq.(1), ideal spoiling.</p><p><em>INPUTS</em>:</p><ul><li><code>α::Real</code> (1,), tip angle in degree;</li></ul><p><em>KEYWORDS</em>:</p><ul><li><code>TR::T0D</code> (1,), repetition time;</li><li><code>T1::T0D</code> (1,), longitudinal relaxation coefficient;</li></ul><p><em>OUTPUTS</em>:</p><ul><li><code>sig::Real</code> (1,), steady-state signal.</li></ul><p>See also: <a href="#MRphy.SteadyStates.Signal.bSSFP-Tuple{Real}"><code>bSSFP</code></a>, <a href="#MRphy.SteadyStates.Signal.STFR-Tuple{Real,Real}"><code>STFR</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/SteadyStates.jl#L44-L57">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MRphy.SteadyStates.Signal.STFR-Tuple{Real,Real}" href="#MRphy.SteadyStates.Signal.STFR-Tuple{Real,Real}"><code>MRphy.SteadyStates.Signal.STFR</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">STFR(α, β; ϕ, Δf, T1, T2, Tg, Tf)</code></pre><p><code>TE=0</code> Steady state STFR signal. 10.1002/mrm.25146, eq.(2), ideal spoiling.</p><p><em>INPUTS</em>:</p><ul><li><code>α::Real</code> (1,), tip-down angle in degree;</li><li><code>β::Real</code> (1,), tip-up angle in degree;</li></ul><p><em>KEYWORDS</em>:</p><ul><li><code>ϕ::Real</code> (1,), phase of the tip-up pulse in radians;</li><li><code>Δf::F0D</code> (1,), off-resonance in Hz;</li><li><code>T1::T0D</code> (1,), longitudinal relaxation coefficient;</li><li><code>T2::T0D</code> (1,), transverse relaxation coefficient;</li><li><code>Tg::T0D</code> (1,), duration of gradient crusher;</li><li><code>Tf::T0D</code> (1,), duration of free precession in each TR;</li></ul><p><em>OUTPUTS</em>:</p><ul><li><code>sig::Real</code> (1,), steady-state signal.</li></ul><p>See also: <a href="#MRphy.SteadyStates.Signal.bSSFP-Tuple{Real}"><code>bSSFP</code></a>, <a href="#MRphy.SteadyStates.Signal.SPGR-Tuple{Real}"><code>SPGR</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/SteadyStates.jl#L61-L79">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MRphy.SteadyStates.Signal.bSSFP-Tuple{Real}" href="#MRphy.SteadyStates.Signal.bSSFP-Tuple{Real}"><code>MRphy.SteadyStates.Signal.bSSFP</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">bSSFP(α; TR, Δf, T1, T2)</code></pre><p><code>TE=0</code> Steady state bSSFP signal. 10.1002/jmri.24163, eq.(4), with <code>ϕ=2π*Δf*TR</code>.</p><p><em>INPUTS</em>:</p><ul><li><code>α::Real</code> (1,), tip angle in degree;</li></ul><p><em>KEYWORDS</em>:</p><ul><li><code>TR::T0D</code> (1,), repetition time;</li><li><code>Δf::F0D</code> (1,), off-resonance in Hz;</li><li><code>T1::T0D</code> (1,), longitudinal relaxation coefficient;</li><li><code>T2::T0D</code> (1,), transverse relaxation coefficient;</li></ul><p><em>OUTPUTS</em>:</p><ul><li><code>sig::Complex</code> (1,), steady-state signal.</li></ul><p>See also: <a href="#MRphy.SteadyStates.Signal.SPGR-Tuple{Real}"><code>SPGR</code></a>, <a href="#MRphy.SteadyStates.Signal.STFR-Tuple{Real,Real}"><code>STFR</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/SteadyStates.jl#L17-L32">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MRphy.SteadyStates.RFSpoiling.FZstates-Tuple{AbstractArray{D,2} where D&lt;:Real,Real}" href="#MRphy.SteadyStates.RFSpoiling.FZstates-Tuple{AbstractArray{D,2} where D&lt;:Real,Real}"><code>MRphy.SteadyStates.RFSpoiling.FZstates</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">FZstates(Φ, α; TR, T1, T2, FZ)</code></pre><p>𝐹, 𝑍 from: 10.1002/(SICI)1099-0534(1999)11:5&lt;291::AID-CMR2&gt;3.0.CO;2-J, eq.(7,8). eq.(7) refined to <code>÷√(2)</code>, instead of <code>÷2</code>, as in 10.1002/mrm20736: eq.(2).</p><p>Assume constant gradient spoiling of m⋅2π dephasing in each TR, m∈ℤ. In practice, if dephase is a constant but not exactly m⋅2π, the resulting states can be computed by convolving a sinc with the m⋅2π dephased results.</p><p><em>INPUTS</em>:</p><ul><li><code>Φ::TypeND(Real,[2])</code> (nC,nTR), nC: #<code>C</code> as <code>C</code> in <code>QuadPhase</code>. Typically, one simulates a range of <code>C</code>s, picking a <code>C</code> yielding a signal intensity equals to that of ideal spgr spoiling.</li><li><code>α::Real</code> (1,), flip-angle.</li></ul><p><em>KEYWORDS</em>:</p><ul><li><code>TR::T0D</code> (1,), repetition time;</li><li><code>T1::T0D</code> (1,), longitudinal relaxation coefficient;</li><li><code>T2::T0D</code> (1,), transverse relaxation coefficient;</li><li><code>FZ::NamedTuple</code>, <code>(Fs,Fcs,Zs)</code>, simulate from prescribed states if given:<br/><code>Fs ::TypeND(Complex,[2])</code>, transversal dephasing states, 𝐹ₙ;<br/><code>Fcs::TypeND(Complex,[2])</code>, conjugate transversal dephasing states, 𝐹₋ₙ*;<br/><code>Zs ::TypeND(Complex,[2])</code>, longitudinal states, 𝑍ₙ;</li></ul><p><em>OUTPUTS</em>:</p><ul><li><code>FZ::NamedTuple</code>, <code>(Fs,Fcs,Zs)</code>, simulation results.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/SteadyStates.jl#L111-L135">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MRphy.SteadyStates.RFSpoiling.QuadPhase" href="#MRphy.SteadyStates.RFSpoiling.QuadPhase"><code>MRphy.SteadyStates.RFSpoiling.QuadPhase</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">QuadPhase(nTR::Integer, C::Real, B::Real, A::Real)</code></pre><p>Quadratically cycling phases in (°): Φ(n) = mod.(C⋅n² + B⋅n + A, 360), n=0:nTR-1</p></div></div><a class="source-link" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/d05a32ac6085203531a3f691d1c532fbbe4efb52/src/SteadyStates.jl#L104-L107">source</a></section><h1><a class="nav-anchor" id="Index-1" href="#Index-1">Index</a></h1><ul><li><a href="#MRphy"><code>MRphy</code></a></li><li><a href="#MRphy.SteadyStates"><code>MRphy.SteadyStates</code></a></li><li><a href="#MRphy.SteadyStates.RFSpoiling"><code>MRphy.SteadyStates.RFSpoiling</code></a></li><li><a href="#MRphy.SteadyStates.Signal"><code>MRphy.SteadyStates.Signal</code></a></li><li><a href="#MRphy.utils"><code>MRphy.utils</code></a></li><li><a href="#MRphy.γ¹H"><code>MRphy.γ¹H</code></a></li><li><a href="#MRphy.AbstractPulse"><code>MRphy.AbstractPulse</code></a></li><li><a href="#MRphy.AbstractSpinArray"><code>MRphy.AbstractSpinArray</code></a></li><li><a href="#MRphy.AbstractSpinBolus"><code>MRphy.AbstractSpinBolus</code></a></li><li><a href="#MRphy.AbstractSpinCube"><code>MRphy.AbstractSpinCube</code></a></li><li><a href="#MRphy.B0D"><code>MRphy.B0D</code></a></li><li><a href="#MRphy.F0D"><code>MRphy.F0D</code></a></li><li><a href="#MRphy.GR0D"><code>MRphy.GR0D</code></a></li><li><a href="#MRphy.K0D"><code>MRphy.K0D</code></a></li><li><a href="#MRphy.L0D"><code>MRphy.L0D</code></a></li><li><a href="#MRphy.Pulse"><code>MRphy.Pulse</code></a></li><li><a href="#MRphy.RF0D"><code>MRphy.RF0D</code></a></li><li><a href="#MRphy.T0D"><code>MRphy.T0D</code></a></li><li><a href="#MRphy.mSpinArray"><code>MRphy.mSpinArray</code></a></li><li><a href="#MRphy.mSpinBolus"><code>MRphy.mSpinBolus</code></a></li><li><a href="#MRphy.mSpinCube"><code>MRphy.mSpinCube</code></a></li><li><a href="#MRphy.Γ0D"><code>MRphy.Γ0D</code></a></li><li><a href="#MRphy.B2AB"><code>MRphy.B2AB</code></a></li><li><a href="#MRphy.B2UΦ"><code>MRphy.B2UΦ</code></a></li><li><a href="#MRphy.B2UΦ!"><code>MRphy.B2UΦ!</code></a></li><li><a href="#MRphy.ExceptionImmutableField"><code>MRphy.ExceptionImmutableField</code></a></li><li><a href="#MRphy.Pulse2B"><code>MRphy.Pulse2B</code></a></li><li><a href="#MRphy.SteadyStates.RFSpoiling.FZstates-Tuple{AbstractArray{D,2} where D&lt;:Real,Real}"><code>MRphy.SteadyStates.RFSpoiling.FZstates</code></a></li><li><a href="#MRphy.SteadyStates.RFSpoiling.QuadPhase"><code>MRphy.SteadyStates.RFSpoiling.QuadPhase</code></a></li><li><a href="#MRphy.SteadyStates.Signal.SPGR-Tuple{Real}"><code>MRphy.SteadyStates.Signal.SPGR</code></a></li><li><a href="#MRphy.SteadyStates.Signal.STFR-Tuple{Real,Real}"><code>MRphy.SteadyStates.Signal.STFR</code></a></li><li><a href="#MRphy.SteadyStates.Signal.bSSFP-Tuple{Real}"><code>MRphy.SteadyStates.Signal.bSSFP</code></a></li><li><a href="#MRphy.TypeND"><code>MRphy.TypeND</code></a></li><li><a href="#MRphy.UΦRot"><code>MRphy.UΦRot</code></a></li><li><a href="#MRphy.UΦRot!"><code>MRphy.UΦRot!</code></a></li><li><a href="#MRphy.applyPulse"><code>MRphy.applyPulse</code></a></li><li><a href="#MRphy.applyPulse!"><code>MRphy.applyPulse!</code></a></li><li><a href="#MRphy.blochSim"><code>MRphy.blochSim</code></a></li><li><a href="#MRphy.blochSim!"><code>MRphy.blochSim!</code></a></li><li><a href="#MRphy.freePrec"><code>MRphy.freePrec</code></a></li><li><a href="#MRphy.freePrec!"><code>MRphy.freePrec!</code></a></li><li><a href="#MRphy.rfgr2B"><code>MRphy.rfgr2B</code></a></li><li><a href="#MRphy.utils.CartesianLocations"><code>MRphy.utils.CartesianLocations</code></a></li><li><a href="#MRphy.utils.ctrInd-Tuple{Tuple{Vararg{Int64,N}} where N}"><code>MRphy.utils.ctrInd</code></a></li><li><a href="#MRphy.utils.ctrSub-Tuple{Tuple{Vararg{Int64,N}} where N}"><code>MRphy.utils.ctrSub</code></a></li><li><a href="#MRphy.utils.g2k"><code>MRphy.utils.g2k</code></a></li><li><a href="#MRphy.utils.g2s-Tuple{AbstractArray{#s12,N} where N where #s12&lt;:(Unitful.Quantity{#s12,𝐌*𝐈^-1*𝐋^-1*𝐓^-2,U} where U where #s12&lt;:Real)}"><code>MRphy.utils.g2s</code></a></li><li><a href="#MRphy.utils.k2g"><code>MRphy.utils.k2g</code></a></li></ul><footer><hr/></footer></article></body></html>
